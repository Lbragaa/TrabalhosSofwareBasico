========= TRABALHO G1 - SOFTWARE BÁSICO - INF 1018 =========

///////////////////////////////////////////

Integrantes do grupo:

   • Luan Carlos Almada Braga 2411776 3WA

   • Diogo Lins Benchimol  2312917  3WA

///////////////////////////////////////////

DESCRICAO DE TESTES REALIZADOS E COMPORTAMENTO OBSERVADO

Para garantirmos que o programa funcionava corretamnte, realizamos uma variedade de testes com diferentes estruturas, cobrindo todos os tipos exigidos no enunciado ('i', 'u' e 'sNN'), bem como situações limites e combinações variadas. 
A seleção dos testes busca validar não apenas o funcionamento básico, mas também a robustez da implementação em casos extremos (strings no limite, inteiros com múltiplos bytes, etc.).

Também incluímos o exemplo exato presente no enunciado como primeiro teste para garantir compatibilidade total com os exemplos fornecidos.

Cada teste abaixo é estruturado da seguinte forma:

///////////////////////////////////////////
[Separador visual entre os testes]

== Teste n ==

Struct utilizada:
struct X { ... };

Valores utilizados: descrição breve dos dados utilizados
Campo de descrição: "..."

=========================================
[Separador entre entrada e saída]

Comportamento observado:
Saída real do mostracomp.

///////////////////////////////////////////

== Teste 1 – Exemplo do enunciado ==

Valida se a implementação corresponde exatamente ao exemplo descrito no enunciado do trabalho.

Struct utilizada:
struct Ex1 { int i; char s1[5]; unsigned u; };

Valores utilizados: dois elementos — { -1, "abc", 258 }, { 1, "ABCD", 65535 }
Campo de descrição: "is05u"

=========================================

Comportamento observado:
Estruturas: 2
(int) -1 (ffffffff)
(str) abc
(uns) 258 (00000102)

(int) 1 (00000001)
(str) ABCD
(uns) 65535 (0000ffff)

///////////////////////////////////////////

== Teste 2 – Int com 3 bytes (−2^24) ==

Confirma que inteiros negativos grandes (como −2^24) são armazenados com compactação correta (3 bytes).

Struct utilizada:
struct A { int32_t si; };

Valores utilizados: -16777216
Campo de descrição: "i"

=========================================

Comportamento observado:
Estruturas: 1
(int) -16777216 (ff000000)

///////////////////////////////////////////

== Teste 3 – Unsigned zero ==

Struct utilizada:
struct B { unsigned u; };

Valores utilizados: 0
Campo de descrição: "u"

=========================================

Comportamento observado:
Estruturas: 1
(uns) 0 (00000000)

///////////////////////////////////////////

== Teste 4 – String com 63 caracteres ==

Garante que strings com o comprimento máximo permitido são tratadas corretamente (sem extrapolar limites).

Struct utilizada:
struct C { char s[64]; };

Valores utilizados: string com 63 letras 'X' + '\0'
Campo de descrição: "s64"

=========================================

Comportamento observado:
Estruturas: 1
(str) XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

///////////////////////////////////////////

== Teste 5 – Inteiro negativo e unsigned médio ==

Confirma leitura e escrita correta de dois campos básicos em sequência: int negativo e unsigned > 255.

Struct utilizada:
struct D { int32_t si; unsigned u; };

Valores utilizados: -1, 258
Campo de descrição: "iu"

=========================================

Comportamento observado:
Estruturas: 1
(int) -1 (ffffffff)
(uns) 258 (00000102)

///////////////////////////////////////////

== Teste 6 – Três structs simples (int + char[2]) ==

Testa múltiplos elementos com strings mínimas e verifica formatação com quebras corretas entre structs, já que haviam problemas de formatação(não mais presentes).

Struct utilizada:
struct E { int32_t si; char s[2]; };

Valores utilizados: (1, "a"), (2, "b"), (3, "c")
Campo de descrição: "is02"

=========================================

Comportamento observado:
Estruturas: 3
(int) 1 (00000001)
(str) a

(int) 2 (00000002)
(str) b

(int) 3 (00000003)
(str) c

///////////////////////////////////////////

== Teste 7 – String + maior unsigned possível ==

Confirma funcionamento com o maior valor possível de unsigned int (0xFFFFFFFF).

Struct utilizada:
struct F { char s[3]; unsigned u; };

Valores utilizados: ("&l", 4294967295)
Campo de descrição: "s03u"

=========================================

Comportamento observado:
Estruturas: 1
(str) &l
(uns) 4294967295 (ffffffff)

///////////////////////////////////////////

== Teste 8 – Dois inteiros, um positivo e um negativo ==

Valida múltiplos inteiros com sinais diferentes, garantindo que ambos são representados corretamente.

Struct utilizada:
struct G { int32_t si; };

Valores utilizados: 123456789 e -987654321
Campo de descrição: "i"

=========================================

Comportamento observado:
Estruturas: 2
(int) 123456789 (075bcd15)
(int) -987654321 (c521974f)

///////////////////////////////////////////

== Teste 9 – Inteiro + string curta + unsigned ==

Verifica combinação completa dos três tipos e checa se o alinhamento geral da struct está correto.

Struct utilizada:
struct H { int32_t si; char s[3]; unsigned u; };

Valores utilizados: (42, "ok", 256)
Campo de descrição: "is03u"

=========================================

Comportamento observado:
Estruturas: 1
(int) 42 (0000002a)
(str) ok
(uns) 256 (00000100)

///////////////////////////////////////////

== Teste 10 – Apenas strings (três elementos) ==

Garante que leitura de várias strings em sequência funciona corretamente.

Struct utilizada:
struct I { char s[6]; };

Valores utilizados: "a", "PUC", "RIO"
Campo de descrição: "s06"

=========================================

Comportamento observado:
Estruturas: 3
(str) a
(str) PUC
(str) RIO

///////////////////////////////////////////

== Teste 11 – Unsigned, int, string[4] ==

Verifica se a ordem dos campos afeta corretamente o cabeçalho e a reconstrução posterior.

Struct utilizada:
struct J { unsigned u; int32_t si; char s[4]; };

Valores utilizados: (1000, -55, "Puc")
Campo de descrição: "uis04"

=========================================

Comportamento observado:
Estruturas: 1
(uns) 1000 (000003e8)
(int) -55 (ffffffc9)
(str) Puc

///////////////////////////////////////////

CONSIDERAÇÕES FINAIS

A partir da execução desses testes, concluímos que a implementação atende todas as especificações propostas. A gravacomp escreve corretamente os campos em formato compactado conforme descrito (incluindo tratamento de alinhamento e tamanho variável dos campos), e a mostracomp reinterpreta e imprime os dados com fidelidade.

Testes extremos, como o uso de inteiros negativos grandes, strings no limite de 63 caracteres e valores de unsigned no limite, foram devidamente realizados e aprovados, demonstrando robustez da implementação. Também validamos o uso de alocação dinâmica na conversão do descritor, o que elimina a limitação artificial de número de campos.
